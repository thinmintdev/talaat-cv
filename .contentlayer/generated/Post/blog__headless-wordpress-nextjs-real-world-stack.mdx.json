{
  "title": "Headless WordPress on Next.js: A Real‑World Stack That Doesn’t Hurt",
  "publishedAt": "2025-08-08T00:00:00.000Z",
  "summary": "Practical headless WordPress with Next.js using WPGraphQL, ISR, and editor‑friendly previews without yak shaving.",
  "tags": [
    "Headless WordPress",
    "Next.js",
    "WPGraphQL",
    "ISR"
  ],
  "draft": false,
  "featured": true,
  "body": {
    "raw": "\nIf you want headless WordPress without the drama, you need three things to feel boringly reliable: a clean schema (WPGraphQL), predictable caching (ISR + on‑demand revalidation), and previews that feel native to editors. The stack below is opinionated, repeatable, and battle‑tested on real launches.\n\n## Architecture at a glance\n\n- Authoring: WordPress with WPGraphQL, ACF, and ACF GraphQL\n- Delivery: Next.js App Router (RSC), edge cache via your host (e.g., Vercel)\n- Data: GraphQL queries with typed fragments; cache tags for precise invalidation\n- Previews: token‑based preview cookie → draft fetches (`cache: 'no-store'`)\n- DX: contentlayer for MDX docs/notes that live in the repo alongside CMS pages\n\nWhy this works: WordPress remains an excellent editor experience; Next.js gives you modern rendering, data ownership, and performance. The glue is WPGraphQL with a schema that you actually control.\n\n## The WordPress side: keep it simple, keep it consistent\n\nRequired plugins:\n\n- WPGraphQL\n- ACF Pro + WPGraphQL for ACF\n- (Optional) WPGraphQL Smart Cache (adds cache bust webhooks)\n- (Optional) WPGraphQL Yoast (if you use Yoast SEO fields)\n\nConventions that pay off later:\n\n- Use ACF field groups with consistent field keys and locations (e.g., “Post: SEO”, “Post: Hero”).\n- Favor primitive fields + repeaters over deeply nested flexible content until you truly need it.\n- Lock down roles and capabilities (Editors publish; Authors draft; no plugin installation in production).\n\n## Modeling content with GraphQL fragments\n\nKeep your queries small, typed, and reusable with fragments. Example post fragments:\n\n```graphql\nfragment SeoFields on Post {\n  seo: seo {\n    title\n    metaDesc\n    opengraphImage {\n      mediaItemUrl\n      altText\n    }\n  }\n}\n\nfragment PostCard on Post {\n  slug\n  title\n  date\n  excerpt\n  featuredImage {\n    node { sourceUrl altText }\n  }\n}\n\nquery PostBySlug($slug: ID!) {\n  post(id: $slug, idType: SLUG) {\n    ...SeoFields\n    content\n    ...PostCard\n  }\n}\n```\n\nPro tip: generate TypeScript types from your GraphQL schema (e.g., `graphql-code-generator`) so your Next.js code gets real intellisense and nullability.\n\n## Next.js data‑fetching: RSC by default, opt into client only when needed\n\nIn the App Router, fetch content in server components for maximum cache control. Tag your queries so you can surgically invalidate later.\n\n```ts\n// lib/wp.ts\nexport async function wpFetch<T>(query: string, variables?: Record<string, any>, tags: string[] = []) {\n  const res = await fetch(process.env.WP_GRAPHQL_ENDPOINT!, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n    next: { revalidate: 300, tags }, // default 5 min ISR, override per call\n  })\n  if (!res.ok) throw new Error('WPGraphQL fetch failed')\n  const json = await res.json()\n  if (json.errors) throw new Error(JSON.stringify(json.errors))\n  return json.data as T\n}\n```\n\nUse it in a route segment:\n\n```tsx\n// app/blog/[slug]/page.tsx\nimport { wpFetch } from '@/lib/wp'\nimport { notFound } from 'next/navigation'\n\nexport default async function PostPage({ params }: { params: { slug: string } }) {\n  const data = await wpFetch<{ post: any }>(\n    /* GraphQL */ `query PostBySlug($slug: ID!) { post(id: $slug, idType: SLUG) { title date content } }`,\n    { slug: params.slug },\n    [\"post:\" + params.slug]\n  )\n  if (!data.post) return notFound()\n  return (\n    <article className=\"prose dark:prose-invert\">\n      <h1>{data.post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: data.post.content }} />\n    </article>\n  )\n}\n```\n\n## ISR + On‑demand revalidation you can reason about\n\nRules of thumb:\n\n- Landing/marketing pages: `revalidate: 60` during launches, longer otherwise.\n- Blog posts: `revalidate: 300` and tag by `post:{slug}` so you can revalidate just that one.\n- Taxonomies and lists: tag by `posts` and revalidate when anything publishes.\n\nWire revalidation from WordPress via webhook. You can use WPGraphQL Smart Cache or a tiny custom action.\n\n```php\n// functions.php (theme or mu-plugin)\nadd_action('transition_post_status', function($new_status, $old_status, $post) {\n  if ($post->post_type !== 'post') return;\n  if ($new_status === 'publish') {\n    wp_remote_post(getenv('NEXT_REVALIDATE_ENDPOINT'), [\n      'headers' => ['Authorization' => 'Bearer ' . getenv('REVALIDATE_TOKEN')],\n      'body' => ['slug' => $post->post_name],\n      'timeout' => 5\n    ]);\n  }\n}, 10, 3);\n```\n\n```ts\n// app/api/revalidate/route.ts\nimport { NextResponse } from 'next/server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function POST(req: Request) {\n  const auth = req.headers.get('authorization')\n  if (auth !== `Bearer ${process.env.REVALIDATE_TOKEN}`) return NextResponse.json({ ok: false }, { status: 401 })\n  const { slug } = await req.json()\n  revalidateTag('posts')\n  revalidateTag(`post:${slug}`)\n  return NextResponse.json({ ok: true })\n}\n```\n\n## Previews editors actually trust\n\nPreview flow in 3 steps:\n\n1) Editor clicks Preview in WP → WP opens your Next.js `/api/preview` with a one‑time token.\n2) Your handler validates token, sets a `preview` cookie, redirects to the draft URL.\n3) Pages read the cookie and fetch drafts with `cache: 'no-store'` and explicit `preview: true` inputs.\n\n```ts\n// app/api/preview/route.ts\nimport { cookies } from 'next/headers'\nimport { NextResponse } from 'next/server'\n\nexport async function GET(req: Request) {\n  const { searchParams } = new URL(req.url)\n  const token = searchParams.get('token')\n  if (token !== process.env.WP_PREVIEW_TOKEN) return NextResponse.json({ ok: false }, { status: 401 })\n  cookies().set('wp-preview', '1', { httpOnly: true, secure: true, sameSite: 'lax' })\n  const to = searchParams.get('to') || '/'\n  return NextResponse.redirect(new URL(to, req.url))\n}\n```\n\n```ts\n// lib/wp-preview.ts\nexport async function wpPreviewFetch<T>(query: string, variables?: Record<string, any>) {\n  const res = await fetch(process.env.WP_GRAPHQL_ENDPOINT!, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n    cache: 'no-store',\n  })\n  const json = await res.json()\n  return json.data as T\n}\n```\n\nIn your page, branch on cookie presence (RSC can read headers) and call the preview fetcher.\n\n## Media and images: avoid the slow path\n\n- Use `next/image` with the WordPress domain whitelisted in `next.config.js`.\n- Prefer the `sourceUrl` that maps to an optimized size (e.g., `medium_large`) when available.\n- If you control infra, put a thumbor/imgproxy in front of WordPress and serve every image through it.\n\n## Caching and performance guardrails\n\n- Tag everything; never revalidate the entire site unless truly necessary.\n- Avoid `cache: 'no-store'` except for previews and admin‑only views.\n- Batch GraphQL queries where sensible, but prefer smaller, targeted queries over a giant “one to rule them all.”\n- Consider a micro cache for GraphQL responses (e.g., 30–120 seconds) if your WordPress can’t handle traffic spikes.\n\n## Failure modes you should plan for\n\n- Slug changes: store previous slugs and emit `308` redirects.\n- Deleted posts: return 410 Gone, not 404, to help caches converge.\n- Partial downtime: if WordPress is flaky, keep serving ISR‑cached pages and degrade gracefully on lists.\n- Editor mistakes: required field nulls → guard in renderers; never let a missing image crash a page.\n\n## Security and operations\n\n- Disable file editing in WP (`DISALLOW_FILE_EDIT`), restrict plugin installs.\n- Put WP behind basic auth on non‑production environments.\n- Keep tokens secret; rotate your preview and revalidation tokens periodically.\n- Backups and staging refreshes: scripts, not manual checklists.\n\n## Testing the contract\n\n- Schema drift catches: generate TS types; run `codegen` in CI when schema changes.\n- Critical queries get smoke tests (does `postBySlug` return required fields?).\n- Visual preview baseline: lightweight Playwright test to load draft pages.\n\n## A pragmatic checklist\n\n- [ ] WPGraphQL, ACF, and ACF GraphQL installed and configured\n- [ ] GraphQL fragments for SEO, card, hero blocks\n- [ ] Revalidation endpoint secured and wired to WP webhook\n- [ ] Preview cookie flow implemented and tested end‑to‑end\n- [ ] Image domains whitelisted; large images optimized\n- [ ] Tags applied to all fetches; list + detail cached appropriately\n- [ ] Redirects for slug changes; 410 for deletions\n- [ ] Backups, staging auth, and CI schema checks\n\n## Conclusion\n\nHeadless WordPress doesn’t have to be a maze of plugins and mystery caches. Treat WordPress like a stable editor UI, keep the data model clean in GraphQL, let Next.js own rendering and caching, and give editors previews that look exactly like production. Start simple, tag your fetches, and add complexity only when a real production need shows up. That’s how you ship headless without the headache.\n",
    "code": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},o=(r,e,t,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!f.call(r,i)&&i!==t&&a(r,i,{get:()=>e[i],enumerable:!(s=u(e,i))||s.enumerable});return r};var v=(r,e,t)=>(t=r!=null?p(m(r)):{},o(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),P=r=>o(a({},\"__esModule\",{value:!0}),r);var d=y((T,l)=>{l.exports=_jsx_runtime});var k={};w(k,{default:()=>h,frontmatter:()=>x});var n=v(d()),x={title:\"Headless WordPress on Next.js: A Real\\u2011World Stack That Doesn\\u2019t Hurt\",publishedAt:\"2025-08-08\",summary:\"Practical headless WordPress with Next.js using WPGraphQL, ISR, and editor\\u2011friendly previews without yak shaving.\",tags:[\"Headless WordPress\",\"Next.js\",\"WPGraphQL\",\"ISR\"],featured:!0};function c(r){let e={code:\"code\",h2:\"h2\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",ul:\"ul\",...r.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"If you want headless WordPress without the drama, you need three things to feel boringly reliable: a clean schema (WPGraphQL), predictable caching (ISR + on\\u2011demand revalidation), and previews that feel native to editors. The stack below is opinionated, repeatable, and battle\\u2011tested on real launches.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Architecture at a glance\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Authoring: WordPress with WPGraphQL, ACF, and ACF GraphQL\"}),`\n`,(0,n.jsx)(e.li,{children:\"Delivery: Next.js App Router (RSC), edge cache via your host (e.g., Vercel)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Data: GraphQL queries with typed fragments; cache tags for precise invalidation\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Previews: token\\u2011based preview cookie \\u2192 draft fetches (\",(0,n.jsx)(e.code,{children:\"cache: 'no-store'\"}),\")\"]}),`\n`,(0,n.jsx)(e.li,{children:\"DX: contentlayer for MDX docs/notes that live in the repo alongside CMS pages\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Why this works: WordPress remains an excellent editor experience; Next.js gives you modern rendering, data ownership, and performance. The glue is WPGraphQL with a schema that you actually control.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"The WordPress side: keep it simple, keep it consistent\"}),`\n`,(0,n.jsx)(e.p,{children:\"Required plugins:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"WPGraphQL\"}),`\n`,(0,n.jsx)(e.li,{children:\"ACF Pro + WPGraphQL for ACF\"}),`\n`,(0,n.jsx)(e.li,{children:\"(Optional) WPGraphQL Smart Cache (adds cache bust webhooks)\"}),`\n`,(0,n.jsx)(e.li,{children:\"(Optional) WPGraphQL Yoast (if you use Yoast SEO fields)\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Conventions that pay off later:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Use ACF field groups with consistent field keys and locations (e.g., \\u201CPost: SEO\\u201D, \\u201CPost: Hero\\u201D).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Favor primitive fields + repeaters over deeply nested flexible content until you truly need it.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Lock down roles and capabilities (Editors publish; Authors draft; no plugin installation in production).\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Modeling content with GraphQL fragments\"}),`\n`,(0,n.jsx)(e.p,{children:\"Keep your queries small, typed, and reusable with fragments. Example post fragments:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-graphql\",children:`fragment SeoFields on Post {\n  seo: seo {\n    title\n    metaDesc\n    opengraphImage {\n      mediaItemUrl\n      altText\n    }\n  }\n}\n\nfragment PostCard on Post {\n  slug\n  title\n  date\n  excerpt\n  featuredImage {\n    node { sourceUrl altText }\n  }\n}\n\nquery PostBySlug($slug: ID!) {\n  post(id: $slug, idType: SLUG) {\n    ...SeoFields\n    content\n    ...PostCard\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Pro tip: generate TypeScript types from your GraphQL schema (e.g., \",(0,n.jsx)(e.code,{children:\"graphql-code-generator\"}),\") so your Next.js code gets real intellisense and nullability.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Next.js data\\u2011fetching: RSC by default, opt into client only when needed\"}),`\n`,(0,n.jsx)(e.p,{children:\"In the App Router, fetch content in server components for maximum cache control. Tag your queries so you can surgically invalidate later.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// lib/wp.ts\nexport async function wpFetch<T>(query: string, variables?: Record<string, any>, tags: string[] = []) {\n  const res = await fetch(process.env.WP_GRAPHQL_ENDPOINT!, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n    next: { revalidate: 300, tags }, // default 5 min ISR, override per call\n  })\n  if (!res.ok) throw new Error('WPGraphQL fetch failed')\n  const json = await res.json()\n  if (json.errors) throw new Error(JSON.stringify(json.errors))\n  return json.data as T\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Use it in a route segment:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`// app/blog/[slug]/page.tsx\nimport { wpFetch } from '@/lib/wp'\nimport { notFound } from 'next/navigation'\n\nexport default async function PostPage({ params }: { params: { slug: string } }) {\n  const data = await wpFetch<{ post: any }>(\n    /* GraphQL */ \\`query PostBySlug($slug: ID!) { post(id: $slug, idType: SLUG) { title date content } }\\`,\n    { slug: params.slug },\n    [\"post:\" + params.slug]\n  )\n  if (!data.post) return notFound()\n  return (\n    <article className=\"prose dark:prose-invert\">\n      <h1>{data.post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: data.post.content }} />\n    </article>\n  )\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"ISR + On\\u2011demand revalidation you can reason about\"}),`\n`,(0,n.jsx)(e.p,{children:\"Rules of thumb:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Landing/marketing pages: \",(0,n.jsx)(e.code,{children:\"revalidate: 60\"}),\" during launches, longer otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Blog posts: \",(0,n.jsx)(e.code,{children:\"revalidate: 300\"}),\" and tag by \",(0,n.jsx)(e.code,{children:\"post:{slug}\"}),\" so you can revalidate just that one.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Taxonomies and lists: tag by \",(0,n.jsx)(e.code,{children:\"posts\"}),\" and revalidate when anything publishes.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Wire revalidation from WordPress via webhook. You can use WPGraphQL Smart Cache or a tiny custom action.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-php\",children:`// functions.php (theme or mu-plugin)\nadd_action('transition_post_status', function($new_status, $old_status, $post) {\n  if ($post->post_type !== 'post') return;\n  if ($new_status === 'publish') {\n    wp_remote_post(getenv('NEXT_REVALIDATE_ENDPOINT'), [\n      'headers' => ['Authorization' => 'Bearer ' . getenv('REVALIDATE_TOKEN')],\n      'body' => ['slug' => $post->post_name],\n      'timeout' => 5\n    ]);\n  }\n}, 10, 3);\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// app/api/revalidate/route.ts\nimport { NextResponse } from 'next/server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function POST(req: Request) {\n  const auth = req.headers.get('authorization')\n  if (auth !== \\`Bearer \\${process.env.REVALIDATE_TOKEN}\\`) return NextResponse.json({ ok: false }, { status: 401 })\n  const { slug } = await req.json()\n  revalidateTag('posts')\n  revalidateTag(\\`post:\\${slug}\\`)\n  return NextResponse.json({ ok: true })\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Previews editors actually trust\"}),`\n`,(0,n.jsx)(e.p,{children:\"Preview flow in 3 steps:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Editor clicks Preview in WP \\u2192 WP opens your Next.js \",(0,n.jsx)(e.code,{children:\"/api/preview\"}),\" with a one\\u2011time token.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Your handler validates token, sets a \",(0,n.jsx)(e.code,{children:\"preview\"}),\" cookie, redirects to the draft URL.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Pages read the cookie and fetch drafts with \",(0,n.jsx)(e.code,{children:\"cache: 'no-store'\"}),\" and explicit \",(0,n.jsx)(e.code,{children:\"preview: true\"}),\" inputs.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// app/api/preview/route.ts\nimport { cookies } from 'next/headers'\nimport { NextResponse } from 'next/server'\n\nexport async function GET(req: Request) {\n  const { searchParams } = new URL(req.url)\n  const token = searchParams.get('token')\n  if (token !== process.env.WP_PREVIEW_TOKEN) return NextResponse.json({ ok: false }, { status: 401 })\n  cookies().set('wp-preview', '1', { httpOnly: true, secure: true, sameSite: 'lax' })\n  const to = searchParams.get('to') || '/'\n  return NextResponse.redirect(new URL(to, req.url))\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// lib/wp-preview.ts\nexport async function wpPreviewFetch<T>(query: string, variables?: Record<string, any>) {\n  const res = await fetch(process.env.WP_GRAPHQL_ENDPOINT!, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n    cache: 'no-store',\n  })\n  const json = await res.json()\n  return json.data as T\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In your page, branch on cookie presence (RSC can read headers) and call the preview fetcher.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Media and images: avoid the slow path\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"next/image\"}),\" with the WordPress domain whitelisted in \",(0,n.jsx)(e.code,{children:\"next.config.js\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Prefer the \",(0,n.jsx)(e.code,{children:\"sourceUrl\"}),\" that maps to an optimized size (e.g., \",(0,n.jsx)(e.code,{children:\"medium_large\"}),\") when available.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If you control infra, put a thumbor/imgproxy in front of WordPress and serve every image through it.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Caching and performance guardrails\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Tag everything; never revalidate the entire site unless truly necessary.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Avoid \",(0,n.jsx)(e.code,{children:\"cache: 'no-store'\"}),\" except for previews and admin\\u2011only views.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Batch GraphQL queries where sensible, but prefer smaller, targeted queries over a giant \\u201Cone to rule them all.\\u201D\"}),`\n`,(0,n.jsx)(e.li,{children:\"Consider a micro cache for GraphQL responses (e.g., 30\\u2013120 seconds) if your WordPress can\\u2019t handle traffic spikes.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Failure modes you should plan for\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Slug changes: store previous slugs and emit \",(0,n.jsx)(e.code,{children:\"308\"}),\" redirects.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Deleted posts: return 410 Gone, not 404, to help caches converge.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Partial downtime: if WordPress is flaky, keep serving ISR\\u2011cached pages and degrade gracefully on lists.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Editor mistakes: required field nulls \\u2192 guard in renderers; never let a missing image crash a page.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Security and operations\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Disable file editing in WP (\",(0,n.jsx)(e.code,{children:\"DISALLOW_FILE_EDIT\"}),\"), restrict plugin installs.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Put WP behind basic auth on non\\u2011production environments.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Keep tokens secret; rotate your preview and revalidation tokens periodically.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Backups and staging refreshes: scripts, not manual checklists.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Testing the contract\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Schema drift catches: generate TS types; run \",(0,n.jsx)(e.code,{children:\"codegen\"}),\" in CI when schema changes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Critical queries get smoke tests (does \",(0,n.jsx)(e.code,{children:\"postBySlug\"}),\" return required fields?).\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Visual preview baseline: lightweight Playwright test to load draft pages.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"A pragmatic checklist\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"[ ] WPGraphQL, ACF, and ACF GraphQL installed and configured\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] GraphQL fragments for SEO, card, hero blocks\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Revalidation endpoint secured and wired to WP webhook\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Preview cookie flow implemented and tested end\\u2011to\\u2011end\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Image domains whitelisted; large images optimized\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Tags applied to all fetches; list + detail cached appropriately\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Redirects for slug changes; 410 for deletions\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Backups, staging auth, and CI schema checks\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"Headless WordPress doesn\\u2019t have to be a maze of plugins and mystery caches. Treat WordPress like a stable editor UI, keep the data model clean in GraphQL, let Next.js own rendering and caching, and give editors previews that look exactly like production. Start simple, tag your fetches, and add complexity only when a real production need shows up. That\\u2019s how you ship headless without the headache.\"})]})}function h(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,{...r,children:(0,n.jsx)(c,{...r})}):c(r)}return P(k);})();\n;return Component;"
  },
  "_id": "blog/headless-wordpress-nextjs-real-world-stack.mdx",
  "_raw": {
    "sourceFilePath": "blog/headless-wordpress-nextjs-real-world-stack.mdx",
    "sourceFileName": "headless-wordpress-nextjs-real-world-stack.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/headless-wordpress-nextjs-real-world-stack"
  },
  "type": "Post",
  "readingTime": {
    "text": "7 min read",
    "minutes": 6.38,
    "time": 382800,
    "words": 1276
  },
  "slug": "headless-wordpress-nextjs-real-world-stack",
  "path": "blog/headless-wordpress-nextjs-real-world-stack",
  "filePath": "blog/headless-wordpress-nextjs-real-world-stack.mdx"
}