{
  "title": "Claude Code + SuperClaude: Workflows That Actually Save Time",
  "publishedAt": "2025-08-08T00:00:00.000Z",
  "summary": "The Claude workflows I run daily—scaffolds, migrations, and performance audits—with real configs you can copy.",
  "tags": [
    "Claude Code",
    "SuperClaude",
    "Workflows",
    "Productivity"
  ],
  "draft": false,
  "featured": true,
  "body": {
    "raw": "\nI don’t ask Claude to “build the app.” I ask it to do the high‑leverage, low‑joy work so I can keep my head in the architecture: scaffolding, migrations, refactors, performance hunts, and safety checks. SuperClaude turns those into repeatable workflows you can run and re‑run without fear.\n\nThis is the playbook I actually use—commands, configs, and the guardrails that save hours without creating a black box.\n\n## The philosophy: fewer keystrokes, more certainty\n\nGood AI workflows shouldn’t surprise your teammates or break CI. The litmus test:\n\n- Re‑runnable: If you run the command twice, the second run should be a no‑op.\n- Diffable: Every change is visible in a PR; no hidden state.\n- Test‑aware: Where risk is high, tests appear with the code.\n- Convention‑first: Output matches your existing patterns (naming, lint, types).\n\nSuperClaude encodes those expectations with personas, quality gates, and wave orchestration.\n\n## My SuperClaude base config\n\n```yaml\n# ~/.claude/superclaude/config.yml\npersonas:\n  default: architect\n  frontend: frontend\n  backend: backend\n\nquality_gates:\n  typescript_check: true\n  lint_validation: true\n  test_coverage: 75\n  forbid_todo: true\n\nwave_orchestration:\n  auto_delegation: true\n  complexity_threshold: 0.6\n  max_concurrent: 5\n  commit_granularity: feature\n\nconventions:\n  component_style: tailwind\n  test_runner: vitest\n  e2e: playwright\n  api_validation: zod\n  env_management: dotenv\n```\n\nThis tells SuperClaude how “opinionated” to be. The higher the quality gates, the more often the agent will pause and ask for confirmation or produce tests.\n\n## Workflow 1: Component scaffolds you won’t have to re‑do\n\nSlash command:\n\n```\n/component Button --style tailwind --tests --a11y\n```\n\nWhat it does (and why it saves time):\n\n1) Creates `src/components/Button/Button.tsx` with typed props and variants.\n2) Generates `Button.test.tsx` (RTL + happy/error states) and `Button.stories.tsx`.\n3) Emits `index.ts` barrel, updates central `src/components/index.ts` if you have one.\n4) Lints, typechecks, and runs tests before offering the diff.\n\nExample output (trimmed to key parts):\n\n```tsx\n// src/components/Button/Button.tsx\nimport { cva, type VariantProps } from 'class-variance-authority'\nimport { cn } from '@/lib/utils'\n\nconst button = cva('inline-flex items-center rounded-md font-medium focus:outline-none focus:ring-2', {\n  variants: {\n    variant: {\n      primary: 'bg-blue-600 text-white hover:bg-blue-700',\n      ghost: 'bg-transparent text-gray-900 hover:bg-gray-100 dark:text-gray-100 dark:hover:bg-gray-800',\n    },\n    size: {\n      sm: 'px-2.5 py-1.5 text-sm',\n      md: 'px-3 py-2 text-sm',\n      lg: 'px-4 py-2.5 text-base',\n    },\n  },\n  defaultVariants: { variant: 'primary', size: 'md' },\n})\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof button> {}\nexport function Button({ className, variant, size, ...props }: ButtonProps) {\n  return <button className={cn(button({ variant, size }), className)} {...props} />\n}\n```\n\nPitfalls avoided:\n\n- It won’t create duplicate exports; it checks existing indices.\n- It matches your ESLint/Prettier configs.\n- It uses your `cn`/CVA stack if present; otherwise, it falls back cleanly.\n\n## Workflow 2: State management migration without the big‑bang rewrite\n\nCommand:\n\n```\n/migrate redux zustand --slices auth,cart,ui --keep-actions --pr\n```\n\nThe migration plan the agent generates (and executes if approved):\n\n1) Inventory: where Redux is imported, slice shapes, thunk usage, selectors.\n2) Adapter layer: create Zustand stores that mirror slice state and actions.\n3) Incremental switch: component by component, replace `useSelector` with store hooks.\n4) Tests: Snapshot a few critical selectors; ensure behavior parity.\n5) Cleanup: remove unused reducers/middleware, strip Redux devtools.\n\nExample adapter snippet:\n\n```ts\n// src/store/auth.ts\nimport { create } from 'zustand'\n\ntype State = { user: { id: string; email: string } | null; token?: string }\ntype Actions = { login: (user: State['user'], token?: string) => void; logout: () => void }\n\nexport const useAuth = create<State & Actions>((set) => ({\n  user: null,\n  login: (user, token) => set({ user, token }),\n  logout: () => set({ user: null, token: undefined }),\n}))\n```\n\nSafety rails:\n\n- The agent groups commits per slice so you can revert in isolation.\n- It inserts TODO comments only behind a `--allow-todo` flag; otherwise, it files issues.\n- It leaves the Redux store in place until the last consumer moves.\n\n## Workflow 3: Performance audits that land as green PRs\n\nCommand:\n\n```\n/optimize bundle --metrics lighthouse --target LCP,TBT\n```\n\nWhat you get:\n\n- A baseline Lighthouse report committed to `docs/perf/DATE.md`.\n- An optimization plan ranked by ROI (code split routes X/Y, convert unoptimized images A/B, lazy‑load charts).\n- A PR with atomic commits and a follow‑up report re‑run showing deltas.\n\nRepresentative change:\n\n```tsx\n// Before: dashboard imports the heavy chart lib at module scope\nimport Chart from 'super-charts'\n\n// After: lazy import with SSR guard\nconst Chart = dynamic(() => import('super-charts'), { ssr: false, loading: () => <Spinner /> })\n```\n\nGuardrails:\n\n- It won’t ship `ssr: false` on pages that render above the fold without a placeholder.\n- It refuses to inline large images; it switches to `next/image` or a CDN URL.\n\n## Wave orchestration: getting the order right\n\n“Waves” are staged passes: analyze → plan → refactor → validate. For complex changes, the tool proposes waves and pauses between them.\n\nExample for a design‑system adoption:\n\n1) Inventory usage of Tailwind utilities and bespoke CSS modules.\n2) Introduce primitives (Button, Input, Card) with CVA and tokens.\n3) Replace instances in low‑risk pages; run visual tests.\n4) Roll through critical flows; measure regressions.\n\nThe orchestration prevents giant diffs that are hard to review and even harder to roll back.\n\n## Personas: targeted competence on demand\n\n- Architect: cares about boundaries, types, and interfaces.\n- Frontend: optimizes a11y, focus rings, keyboard traps.\n- Backend: trims allocations, standardizes error envelopes, adds Zod validation.\n- Performance: chases LCP/INP; caches right, not just hard.\n\nSelect with flags or set per‑project defaults in the config.\n\n## MCP integration: tools, not magic\n\nThe agent is strongest when it can look things up and run checks. Useful servers:\n\n- Context7 for docs lookup (framework APIs)\n- Sequential for deep analysis\n- Playwright for smoke testing\n\nHook them in your Claude config and they’ll light up for relevant commands.\n\n## Keeping humans in the loop\n\n- Always request a plan before execution on wide‑ranging changes.\n- Ask for a commit breakdown ahead of time; review sequence matters.\n- Expect the agent to write tests when it modifies behavior. If it can’t, it should file an issue with a failing reproduction you can complete.\n\n## Common pitfalls and how to avoid them\n\n- Letting unstaged changes confuse the agent: commit or stash before large runs.\n- Accepting API schema guesses: provide types or a schema file; the agent will respect them.\n- Allowing hidden TODOs to creep in: fail builds on `TODO(` unless a flag explicitly allows.\n\n## A practical checklist\n\n- [ ] Base config with personas, gates, and conventions checked into the repo\n- [ ] Slash commands `/component`, `/migrate`, `/optimize` (documented for the team)\n- [ ] CI jobs for typecheck, lint, unit, and a quick e2e smoke\n- [ ] Playwright smoke script for top 3 flows\n- [ ] A “no hidden TODOs” rule or bot\n\n## Conclusion\n\nSuperClaude + Claude Code shines when you treat it like power tooling, not an autopilot. Keep changes reviewable, tests close to code, and conventions explicit. Start with scaffolds, add migrations, then tackle performance. Over time you’ll build a personal automation layer that feels like you—but faster and more consistent on the work you used to dread.\n",
    "code": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=p(e,r))||a.enumerable});return t};var v=(t,e,i)=>(i=t!=null?u(g(t)):{},s(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>s(o({},\"__esModule\",{value:!0}),t);var c=y((I,l)=>{l.exports=_jsx_runtime});var x={};w(x,{default:()=>h,frontmatter:()=>b});var n=v(c()),b={title:\"Claude Code + SuperClaude: Workflows That Actually Save Time\",publishedAt:\"2025-08-08\",summary:\"The Claude workflows I run daily\\u2014scaffolds, migrations, and performance audits\\u2014with real configs you can copy.\",tags:[\"Claude Code\",\"SuperClaude\",\"Workflows\",\"Productivity\"],featured:!0};function d(t){let e={code:\"code\",h2:\"h2\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"I don\\u2019t ask Claude to \\u201Cbuild the app.\\u201D I ask it to do the high\\u2011leverage, low\\u2011joy work so I can keep my head in the architecture: scaffolding, migrations, refactors, performance hunts, and safety checks. SuperClaude turns those into repeatable workflows you can run and re\\u2011run without fear.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is the playbook I actually use\\u2014commands, configs, and the guardrails that save hours without creating a black box.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"The philosophy: fewer keystrokes, more certainty\"}),`\n`,(0,n.jsx)(e.p,{children:\"Good AI workflows shouldn\\u2019t surprise your teammates or break CI. The litmus test:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Re\\u2011runnable: If you run the command twice, the second run should be a no\\u2011op.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Diffable: Every change is visible in a PR; no hidden state.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Test\\u2011aware: Where risk is high, tests appear with the code.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Convention\\u2011first: Output matches your existing patterns (naming, lint, types).\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"SuperClaude encodes those expectations with personas, quality gates, and wave orchestration.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"My SuperClaude base config\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`# ~/.claude/superclaude/config.yml\npersonas:\n  default: architect\n  frontend: frontend\n  backend: backend\n\nquality_gates:\n  typescript_check: true\n  lint_validation: true\n  test_coverage: 75\n  forbid_todo: true\n\nwave_orchestration:\n  auto_delegation: true\n  complexity_threshold: 0.6\n  max_concurrent: 5\n  commit_granularity: feature\n\nconventions:\n  component_style: tailwind\n  test_runner: vitest\n  e2e: playwright\n  api_validation: zod\n  env_management: dotenv\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This tells SuperClaude how \\u201Copinionated\\u201D to be. The higher the quality gates, the more often the agent will pause and ask for confirmation or produce tests.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Workflow 1: Component scaffolds you won\\u2019t have to re\\u2011do\"}),`\n`,(0,n.jsx)(e.p,{children:\"Slash command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`/component Button --style tailwind --tests --a11y\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"What it does (and why it saves time):\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Creates \",(0,n.jsx)(e.code,{children:\"src/components/Button/Button.tsx\"}),\" with typed props and variants.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Generates \",(0,n.jsx)(e.code,{children:\"Button.test.tsx\"}),\" (RTL + happy/error states) and \",(0,n.jsx)(e.code,{children:\"Button.stories.tsx\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Emits \",(0,n.jsx)(e.code,{children:\"index.ts\"}),\" barrel, updates central \",(0,n.jsx)(e.code,{children:\"src/components/index.ts\"}),\" if you have one.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Lints, typechecks, and runs tests before offering the diff.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Example output (trimmed to key parts):\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`// src/components/Button/Button.tsx\nimport { cva, type VariantProps } from 'class-variance-authority'\nimport { cn } from '@/lib/utils'\n\nconst button = cva('inline-flex items-center rounded-md font-medium focus:outline-none focus:ring-2', {\n  variants: {\n    variant: {\n      primary: 'bg-blue-600 text-white hover:bg-blue-700',\n      ghost: 'bg-transparent text-gray-900 hover:bg-gray-100 dark:text-gray-100 dark:hover:bg-gray-800',\n    },\n    size: {\n      sm: 'px-2.5 py-1.5 text-sm',\n      md: 'px-3 py-2 text-sm',\n      lg: 'px-4 py-2.5 text-base',\n    },\n  },\n  defaultVariants: { variant: 'primary', size: 'md' },\n})\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof button> {}\nexport function Button({ className, variant, size, ...props }: ButtonProps) {\n  return <button className={cn(button({ variant, size }), className)} {...props} />\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Pitfalls avoided:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"It won\\u2019t create duplicate exports; it checks existing indices.\"}),`\n`,(0,n.jsx)(e.li,{children:\"It matches your ESLint/Prettier configs.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"It uses your \",(0,n.jsx)(e.code,{children:\"cn\"}),\"/CVA stack if present; otherwise, it falls back cleanly.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Workflow 2: State management migration without the big\\u2011bang rewrite\"}),`\n`,(0,n.jsx)(e.p,{children:\"Command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`/migrate redux zustand --slices auth,cart,ui --keep-actions --pr\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The migration plan the agent generates (and executes if approved):\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Inventory: where Redux is imported, slice shapes, thunk usage, selectors.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Adapter layer: create Zustand stores that mirror slice state and actions.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Incremental switch: component by component, replace \",(0,n.jsx)(e.code,{children:\"useSelector\"}),\" with store hooks.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Tests: Snapshot a few critical selectors; ensure behavior parity.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Cleanup: remove unused reducers/middleware, strip Redux devtools.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Example adapter snippet:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// src/store/auth.ts\nimport { create } from 'zustand'\n\ntype State = { user: { id: string; email: string } | null; token?: string }\ntype Actions = { login: (user: State['user'], token?: string) => void; logout: () => void }\n\nexport const useAuth = create<State & Actions>((set) => ({\n  user: null,\n  login: (user, token) => set({ user, token }),\n  logout: () => set({ user: null, token: undefined }),\n}))\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Safety rails:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The agent groups commits per slice so you can revert in isolation.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"It inserts TODO comments only behind a \",(0,n.jsx)(e.code,{children:\"--allow-todo\"}),\" flag; otherwise, it files issues.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"It leaves the Redux store in place until the last consumer moves.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Workflow 3: Performance audits that land as green PRs\"}),`\n`,(0,n.jsx)(e.p,{children:\"Command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`/optimize bundle --metrics lighthouse --target LCP,TBT\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"What you get:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A baseline Lighthouse report committed to \",(0,n.jsx)(e.code,{children:\"docs/perf/DATE.md\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"An optimization plan ranked by ROI (code split routes X/Y, convert unoptimized images A/B, lazy\\u2011load charts).\"}),`\n`,(0,n.jsx)(e.li,{children:\"A PR with atomic commits and a follow\\u2011up report re\\u2011run showing deltas.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Representative change:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`// Before: dashboard imports the heavy chart lib at module scope\nimport Chart from 'super-charts'\n\n// After: lazy import with SSR guard\nconst Chart = dynamic(() => import('super-charts'), { ssr: false, loading: () => <Spinner /> })\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Guardrails:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It won\\u2019t ship \",(0,n.jsx)(e.code,{children:\"ssr: false\"}),\" on pages that render above the fold without a placeholder.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"It refuses to inline large images; it switches to \",(0,n.jsx)(e.code,{children:\"next/image\"}),\" or a CDN URL.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Wave orchestration: getting the order right\"}),`\n`,(0,n.jsx)(e.p,{children:\"\\u201CWaves\\u201D are staged passes: analyze \\u2192 plan \\u2192 refactor \\u2192 validate. For complex changes, the tool proposes waves and pauses between them.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Example for a design\\u2011system adoption:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Inventory usage of Tailwind utilities and bespoke CSS modules.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Introduce primitives (Button, Input, Card) with CVA and tokens.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Replace instances in low\\u2011risk pages; run visual tests.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Roll through critical flows; measure regressions.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The orchestration prevents giant diffs that are hard to review and even harder to roll back.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Personas: targeted competence on demand\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Architect: cares about boundaries, types, and interfaces.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Frontend: optimizes a11y, focus rings, keyboard traps.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Backend: trims allocations, standardizes error envelopes, adds Zod validation.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Performance: chases LCP/INP; caches right, not just hard.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Select with flags or set per\\u2011project defaults in the config.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"MCP integration: tools, not magic\"}),`\n`,(0,n.jsx)(e.p,{children:\"The agent is strongest when it can look things up and run checks. Useful servers:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Context7 for docs lookup (framework APIs)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Sequential for deep analysis\"}),`\n`,(0,n.jsx)(e.li,{children:\"Playwright for smoke testing\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Hook them in your Claude config and they\\u2019ll light up for relevant commands.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Keeping humans in the loop\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Always request a plan before execution on wide\\u2011ranging changes.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Ask for a commit breakdown ahead of time; review sequence matters.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Expect the agent to write tests when it modifies behavior. If it can\\u2019t, it should file an issue with a failing reproduction you can complete.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Common pitfalls and how to avoid them\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Letting unstaged changes confuse the agent: commit or stash before large runs.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Accepting API schema guesses: provide types or a schema file; the agent will respect them.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Allowing hidden TODOs to creep in: fail builds on \",(0,n.jsx)(e.code,{children:\"TODO(\"}),\" unless a flag explicitly allows.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"A practical checklist\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"[ ] Base config with personas, gates, and conventions checked into the repo\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"[ ] Slash commands \",(0,n.jsx)(e.code,{children:\"/component\"}),\", \",(0,n.jsx)(e.code,{children:\"/migrate\"}),\", \",(0,n.jsx)(e.code,{children:\"/optimize\"}),\" (documented for the team)\"]}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] CI jobs for typecheck, lint, unit, and a quick e2e smoke\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] Playwright smoke script for top 3 flows\"}),`\n`,(0,n.jsx)(e.li,{children:\"[ ] A \\u201Cno hidden TODOs\\u201D rule or bot\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"SuperClaude + Claude Code shines when you treat it like power tooling, not an autopilot. Keep changes reviewable, tests close to code, and conventions explicit. Start with scaffolds, add migrations, then tackle performance. Over time you\\u2019ll build a personal automation layer that feels like you\\u2014but faster and more consistent on the work you used to dread.\"})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}return k(x);})();\n;return Component;"
  },
  "_id": "blog/claude-code-superclaude-workflows.mdx",
  "_raw": {
    "sourceFilePath": "blog/claude-code-superclaude-workflows.mdx",
    "sourceFileName": "claude-code-superclaude-workflows.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/claude-code-superclaude-workflows"
  },
  "type": "Post",
  "readingTime": {
    "text": "6 min read",
    "minutes": 5.81,
    "time": 348600,
    "words": 1162
  },
  "slug": "claude-code-superclaude-workflows",
  "path": "blog/claude-code-superclaude-workflows",
  "filePath": "blog/claude-code-superclaude-workflows.mdx"
}